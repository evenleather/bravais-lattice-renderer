<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Renderer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
            display: flex;
            height: 100vh;
        }

        /* Styles for the left-hand menu */
        .menu-panel {
            width: 25%;
            background-color: #2a2a2a;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }
        
        /* Styles for the tab navigation buttons */
        .menu-nav-button-container {
            display: flex;
            gap: 10px;
        }

        .menu-nav-button {
            flex-grow: 1;
            padding: 10px;
            border: none;
            background-color: #444;
            color: #fff;
            font-family: 'Inter', sans-serif;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        .menu-nav-button:hover {
            background-color: #555;
        }

        .menu-nav-button.active {
            background-color: #007bff;
        }

        /* Styles for the content container */
        .renderer-container {
            flex-grow: 1;
            position: relative;
            background-color: #1a1a1a;
        }
        
        canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            z-index: 10;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }

        label {
            font-size: 14px;
            color: #ccc;
        }

        input[type="number"],
        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #333;
            color: #fff;
            font-size: 14px;
        }

        .axis-info, .atom-info {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 5px;
        }
        
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
        
        #customLatticeInputs {
            display: none; /* Initially hidden */
        }
    </style>
</head>
<body>
    <div class="menu-panel">
        <div class="menu-nav-button-container">
            <button id="latticeNavButton" class="menu-nav-button active">Lattice</button>
            <button id="basisNavButton" class="menu-nav-button">Basis</button>
        </div>

        <div id="latticeTab" class="tab-content active">
            <div class="input-group">
                <label for="latticeType">Lattice Type</label>
                <select id="latticeType">
                    <option value="cubic">Cubic</option>
                    <option value="tetragonal">Tetragonal</option>
                    <option value="orthorhombic">Orthorhombic</option>
                    <option value="hexagonal">Hexagonal</option>
                    <option value="trigonal">Trigonal</option>
                    <option value="monoclinic">Monoclinic</option>
                    <option value="triclinic">Triclinic</option>
                    <option value="custom">Custom</option>
                </select>
            </div>
            
            <div id="customLatticeInputs">
                <div class="input-group">
                    <label for="customA">a (Angstroms)</label>
                    <input type="number" id="customA" value="5" step="0.1">
                </div>
                <div class="input-group">
                    <label for="customB">b (Angstroms)</label>
                    <input type="number" id="customB" value="5" step="0.1">
                </div>
                <div class="input-group">
                    <label for="customC">c (Angstroms)</label>
                    <input type="number" id="customC" value="5" step="0.1">
                </div>
                <div class="input-group">
                    <label for="customAlpha">&alpha; (degrees)</label>
                    <input type="number" id="customAlpha" value="90" step="1">
                </div>
                <div class="input-group">
                    <label for="customBeta">&beta; (degrees)</label>
                    <input type="number" id="customBeta" value="90" step="1">
                </div>
                <div class="input-group">
                    <label for="customGamma">&gamma; (degrees)</label>
                    <input type="number" id="customGamma" value="90" step="1">
                </div>
            </div>

            <div class="input-group">
                <label for="numCellsX">Number of Cells (X)</label>
                <input type="number" id="numCellsX" value="3" min="1" max="10">
            </div>
            <div class="input-group">
                <label for="numCellsY">Number of Cells (Y)</label>
                <input type="number" id="numCellsY" value="3" min="1" max="10">
            </div>
            <div class="input-group">
                <label for="numCellsZ">Number of Cells (Z)</label>
                <input type="number" id="numCellsZ" value="3" min="1" max="10">
            </div>
        </div>

        <div id="basisTab" class="tab-content">
            <div class="input-group">
                <label for="atomCount">Number of Atoms in Basis</label>
                <input type="number" id="atomCount" value="1" min="0" max="10">
            </div>
            <div id="atomInputs">
                <div class="input-group">
                    <label>Atom 1</label>
                    <div class="flex gap-2">
                        <input type="number" class="atom-x" placeholder="x" value="0.5" step="0.1">
                        <input type="number" class="atom-y" placeholder="y" value="0.5" step="0.1">
                        <input type="number" class="atom-z" placeholder="z" value="0.5" step="0.1">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="renderer-container" id="rendererContainer">
        <div class="info-panel">
            <div id="latticeParamsDisplay"></div>
            <div id="basisParamsDisplay"></div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // --- Three.js Scene Setup ---
            let scene, camera, renderer, currentScene, currentCamera;
            const rendererContainer = document.getElementById('rendererContainer');
            const basisScene = new THREE.Scene();
            const basisCamera = new THREE.PerspectiveCamera(75, rendererContainer.clientWidth / rendererContainer.clientHeight, 0.1, 1000);
            
            // Initial scene/camera for the lattice
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, rendererContainer.clientWidth / rendererContainer.clientHeight, 0.1, 1000);

            // Set initial current scene/camera
            currentScene = scene;
            currentCamera = camera;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setClearColor(0x000000, 0); // Transparent background
            renderer.setSize(rendererContainer.clientWidth, rendererContainer.clientHeight);
            rendererContainer.appendChild(renderer.domElement);

            // Controls for camera rotation
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            rendererContainer.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            rendererContainer.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                const rotationSpeed = 0.01;
                currentScene.rotation.y += deltaX * rotationSpeed;
                currentScene.rotation.x += deltaY * rotationSpeed;

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            rendererContainer.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Set up a lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 1, 1);
            scene.add(directionalLight);

            // Same lights for the basis scene
            const ambientLightBasis = new THREE.AmbientLight(0xffffff, 0.5);
            basisScene.add(ambientLightBasis);
            const directionalLightBasis = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLightBasis.position.set(0, 1, 1);
            basisScene.add(directionalLightBasis);

            // --- UI Elements and Event Listeners ---
            const latticeTypeSelect = document.getElementById('latticeType');
            const numCellsXInput = document.getElementById('numCellsX');
            const numCellsYInput = document.getElementById('numCellsY');
            const numCellsZInput = document.getElementById('numCellsZ');
            const atomCountInput = document.getElementById('atomCount');
            const atomInputsContainer = document.getElementById('atomInputs');
            const latticeParamsDisplay = document.getElementById('latticeParamsDisplay');
            const basisParamsDisplay = document.getElementById('basisParamsDisplay');
            
            const latticeNavButton = document.getElementById('latticeNavButton');
            const basisNavButton = document.getElementById('basisNavButton');
            const latticeTab = document.getElementById('latticeTab');
            const basisTab = document.getElementById('basisTab');
            
            const customLatticeInputs = document.getElementById('customLatticeInputs');
            const customAInput = document.getElementById('customA');
            const customBInput = document.getElementById('customB');
            const customCInput = document.getElementById('customC');
            const customAlphaInput = document.getElementById('customAlpha');
            const customBetaInput = document.getElementById('customBeta');
            const customGammaInput = document.getElementById('customGamma');

            // Tab Navigation
            latticeNavButton.addEventListener('click', () => {
                latticeNavButton.classList.add('active');
                basisNavButton.classList.remove('active');
                latticeTab.classList.add('active');
                basisTab.classList.remove('active');
                currentScene = scene;
                currentCamera = camera;
            });
            
            basisNavButton.addEventListener('click', () => {
                basisNavButton.classList.add('active');
                latticeNavButton.classList.remove('active');
                basisTab.classList.add('active');
                latticeTab.classList.remove('active');
                currentScene = basisScene;
                currentCamera = basisCamera;
            });
            
            // Custom Lattice Inputs visibility
            latticeTypeSelect.addEventListener('change', () => {
                if (latticeTypeSelect.value === 'custom') {
                    customLatticeInputs.style.display = 'block';
                } else {
                    customLatticeInputs.style.display = 'none';
                }
                updateLatticeRenderer();
            });

            customAInput.addEventListener('input', updateLatticeRenderer);
            customBInput.addEventListener('input', updateLatticeRenderer);
            customCInput.addEventListener('input', updateLatticeRenderer);
            customAlphaInput.addEventListener('input', updateLatticeRenderer);
            customBetaInput.addEventListener('input', updateLatticeRenderer);
            customGammaInput.addEventListener('input', updateLatticeRenderer);

            numCellsXInput.addEventListener('input', updateLatticeRenderer);
            numCellsYInput.addEventListener('input', updateLatticeRenderer);
            numCellsZInput.addEventListener('input', updateLatticeRenderer);
            atomCountInput.addEventListener('input', updateBasisRenderer);

            function updateAtomInputListeners() {
                const atomInputs = atomInputsContainer.querySelectorAll('.atom-x, .atom-y, .atom-z');
                atomInputs.forEach(input => {
                    input.addEventListener('input', updateBasisRenderer);
                });
            }

            // --- Function to Generate a Unit Cell ---
            function createUnitCell(a, b, c, alpha, beta, gamma) {
                const degreesToRadians = (deg) => deg * Math.PI / 180;
                const alphaRad = degreesToRadians(alpha);
                const betaRad = degreesToRadians(beta);
                const gammaRad = degreesToRadians(gamma);

                const cell = new THREE.Group();
                const lineColor = 0xffffff;

                // Create lattice vectors
                const aVec = new THREE.Vector3(a, 0, 0);
                const bVec = new THREE.Vector3(b * Math.cos(gammaRad), b * Math.sin(gammaRad), 0);
                const cVecX = c * Math.cos(betaRad);
                const cVecY = c * (Math.cos(alphaRad) - Math.cos(betaRad) * Math.cos(gammaRad)) / Math.sin(gammaRad);
                const cVecZ = Math.sqrt(c * c - cVecX * cVecX - cVecY * cVecY);
                const cVec = new THREE.Vector3(cVecX, cVecY, cVecZ);

                // Define cell vertices
                const vertices = [
                    new THREE.Vector3(0, 0, 0),
                    aVec,
                    bVec,
                    cVec,
                    aVec.clone().add(bVec),
                    aVec.clone().add(cVec),
                    bVec.clone().add(cVec),
                    aVec.clone().add(bVec).add(cVec)
                ];

                // Create edges for the unit cell
                const edges = [
                    [0, 1], [0, 2], [0, 3],
                    [1, 4], [1, 5],
                    [2, 4], [2, 6],
                    [3, 5], [3, 6],
                    [4, 7],
                    [5, 7],
                    [6, 7]
                ];

                edges.forEach(edge => {
                    const lineMaterial = new THREE.LineBasicMaterial({ color: lineColor });
                    const points = [vertices[edge[0]], vertices[edge[1]]];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial);
                    cell.add(line);
                });

                return { cell, vectors: { aVec, bVec, cVec } };
            }

            // --- Main Rendering Functions ---
            function updateLatticeRenderer() {
                // Clear the scene
                while (scene.children.length > 0) {
                    scene.remove(scene.children[0]);
                }
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(0, 1, 1);
                scene.add(directionalLight);

                let params;
                const type = latticeTypeSelect.value;
                const numCellsX = parseInt(numCellsXInput.value, 10);
                const numCellsY = parseInt(numCellsYInput.value, 10);
                const numCellsZ = parseInt(numCellsZInput.value, 10);

                if (type === 'cubic') {
                    params = { a: 5, b: 5, c: 5, alpha: 90, beta: 90, gamma: 90, centeringType: 'P' };
                } else if (type === 'tetragonal') {
                    params = { a: 5, b: 5, c: 7, alpha: 90, beta: 90, gamma: 90, centeringType: 'P' };
                } else if (type === 'orthorhombic') {
                    params = { a: 5, b: 6, c: 7, alpha: 90, beta: 90, gamma: 90, centeringType: 'P' };
                } else if (type === 'hexagonal') {
                    params = { a: 5, b: 5, c: 7, alpha: 90, beta: 90, gamma: 120, centeringType: 'P' };
                } else if (type === 'trigonal') {
                    params = { a: 5, b: 5, c: 5, alpha: 80, beta: 80, gamma: 80, centeringType: 'R' };
                } else if (type === 'monoclinic') {
                    params = { a: 5, b: 6, c: 7, alpha: 90, beta: 80, gamma: 90, centeringType: 'P' };
                } else if (type === 'triclinic') {
                    params = { a: 5, b: 6, c: 7, alpha: 80, beta: 70, gamma: 60, centeringType: 'P' };
                } else if (type === 'custom') {
                    params = {
                        a: parseFloat(customAInput.value),
                        b: parseFloat(customBInput.value),
                        c: parseFloat(customCInput.value),
                        alpha: parseFloat(customAlphaInput.value),
                        beta: parseFloat(customBetaInput.value),
                        gamma: parseFloat(customGammaInput.value),
                        centeringType: 'P'
                    };
                }

                if (!params) {
                    latticeParamsDisplay.innerHTML = 'Lattice parameters not found.';
                    return;
                }

                const { a, b, c, alpha, beta, gamma } = params;
                const { cell, vectors } = createUnitCell(a, b, c, alpha, beta, gamma);

                // Generate the lattice grid
                for (let i = 0; i < numCellsX; i++) {
                    for (let j = 0; j < numCellsY; j++) {
                        for (let k = 0; k < numCellsZ; k++) {
                            const newCell = cell.clone();
                            const position = new THREE.Vector3()
                                .add(vectors.aVec.clone().multiplyScalar(i))
                                .add(vectors.bVec.clone().multiplyScalar(j))
                                .add(vectors.cVec.clone().multiplyScalar(k));
                            newCell.position.copy(position);
                            scene.add(newCell);
                        }
                    }
                }

                // Center the lattice grid in the scene
                const boundingBox = new THREE.Box3().setFromObject(scene);
                const center = boundingBox.getCenter(new THREE.Vector3());
                scene.position.sub(center);

                // Position the camera
                const maxDim = Math.max(
                    numCellsX * a,
                    numCellsY * b,
                    numCellsZ * c
                );
                camera.position.z = maxDim * 2;
                camera.lookAt(scene.position);

                latticeParamsDisplay.innerHTML = `
                    <h3>Lattice Parameters:</h3>
                    <p>Unit Cell: a = ${a}, b = ${b}, c = ${c}</p>
                    <p>Angles: &alpha; = ${alpha}&deg;, &beta; = ${beta}&deg;, &gamma; = ${gamma}&deg;</p>
                    <p>Lattice Size: ${numCellsX} x ${numCellsY} x ${numCellsZ} unit cells</p>
                    <p>Centering Type: ${params.centeringType}</p>
                `;
            }

            function updateBasisRenderer() {
                // Clear the basis scene
                while (basisScene.children.length > 0) {
                    basisScene.remove(basisScene.children[0]);
                }
                const ambientLightBasis = new THREE.AmbientLight(0xffffff, 0.5);
                basisScene.add(ambientLightBasis);
                const directionalLightBasis = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLightBasis.position.set(0, 1, 1);
                basisScene.add(directionalLightBasis);

                const atomCount = parseInt(atomCountInput.value, 10);
                let atomInputsHTML = '';
                const atomPositions = [];

                for (let i = 0; i < atomCount; i++) {
                    // Create input fields and store positions
                    atomInputsHTML += `
                        <div class="input-group">
                            <label>Atom ${i + 1}</label>
                            <div class="flex gap-2">
                                <input type="number" class="atom-x" placeholder="x" value="0" step="0.1">
                                <input type="number" class="atom-y" placeholder="y" value="0" step="0.1">
                                <input type="number" class="atom-z" placeholder="z" value="0" step="0.1">
                            </div>
                        </div>
                    `;
                    
                    const x = parseFloat(document.querySelectorAll('.atom-x')[i]?.value) || 0;
                    const y = parseFloat(document.querySelectorAll('.atom-y')[i]?.value) || 0;
                    const z = parseFloat(document.querySelectorAll('.atom-z')[i]?.value) || 0;
                    atomPositions.push({ x, y, z });

                    // Create and add the atom to the scene
                    const geometry = new THREE.SphereGeometry(0.1, 32, 32);
                    const material = new THREE.MeshPhongMaterial({ color: 0xff0000 });
                    const atom = new THREE.Mesh(geometry, material);
                    atom.position.set(x, y, z);
                    basisScene.add(atom);
                }

                // Update the atom input fields in the UI
                atomInputsContainer.innerHTML = atomInputsHTML;
                updateAtomInputListeners();
                
                // Add the unit cell to the basis scene
                const params = { a: 1, b: 1, c: 1, alpha: 90, beta: 90, gamma: 90 };
                const { cell, vectors } = createUnitCell(params.a, params.b, params.c, params.alpha, params.beta, params.gamma);
                basisScene.add(cell);

                // Position the camera
                basisCamera.position.z = 2;
                basisCamera.lookAt(basisScene.position);
                
                // Update the basis info display
                basisParamsDisplay.innerHTML = `
                    <h3>Basis Atoms:</h3>
                    ${atomPositions.map((pos, index) => `<p>Atom ${index + 1}: (${pos.x}, ${pos.y}, ${pos.z})</p>`).join('')}
                `;
            }

            // --- Responsiveness ---
            window.addEventListener('resize', () => {
                const newWidth = rendererContainer.clientWidth;
                const newHeight = rendererContainer.clientHeight;
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                basisCamera.aspect = newWidth / newHeight;
                basisCamera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
            });

            // --- Default Rendering ---
            updateLatticeRenderer();
            updateBasisRenderer();

            // --- Animation Loop ---
            function animate() {
                requestAnimationFrame(animate);
                renderer.render(currentScene, currentCamera);
            }

            animate();
        };
    </script>
</body>
</html>
