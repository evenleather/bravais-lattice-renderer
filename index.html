<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basic 3D Renderer with Menu</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
            display: flex; /* Use flexbox for the two-column layout */
            height: 100vh;
        }

        /* Styles for the left-hand menu */
        .menu-panel {
            width: 25%; /* Occupies 1/4 of the screen width */
            background-color: #2a2a2a;
            padding: 20px;
            box-sizing: border-box; /* Include padding in the width */
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto; /* Enable vertical scrolling */
        }
        
        .menu-panel h2 {
            margin: 0;
            padding: 0;
            border-bottom: 2px solid #444;
            padding-bottom: 10px;
        }

        /* Styles for the tab navigation buttons */
        .menu-nav-button-container {
            display: flex;
            gap: 10px;
        }

        .menu-nav-button {
            flex-grow: 1;
            padding: 12px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 8px;
            border: 2px solid #555;
            background-color: #333;
            color: #ddd;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }

        .menu-nav-button.active {
            background-color: #007bff;
            border-color: #007bff;
            color: #fff;
        }
        
        .menu-nav-button:hover {
            transform: translateY(-2px);
        }
        
        /* Styles for general menu buttons */
        .menu-button {
            background-color: #007bff;
            color: #ffffff;
            border: none;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s ease;
        }

        .menu-button:hover {
            background-color: #0056b3;
        }

        /* Styles for the menu sections that hold content for each tab */
        .menu-section {
            display: none; /* Hide sections by default */
            flex-direction: column;
            gap: 15px;
        }

        .menu-section.active {
            display: flex; /* Show the active section */
        }

        /* Styles for the right-hand renderer container */
        .renderer-container {
            width: 75%; /* Occupies 3/4 of the screen width */
            position: relative;
        }

        canvas {
            display: block;
            touch-action: none; /* Prevent default touch behavior */
            width: 100%;
            height: 100%;
        }

        /* Styles for the number inputs */
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .input-group label {
            font-size: 14px;
            color: #ccc;
        }

        .input-group input[type="number"] {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #333;
            color: #fff;
            font-size: 16px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .input-group-inline {
            display: flex;
            gap: 10px;
        }

        .input-group-inline input[type="number"] {
            width: calc(33.33% - 7px);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .atom-list {
            background-color: #333;
            border-radius: 8px;
            padding: 10px;
            min-height: 50px;
        }

        .atom-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .atom-dot {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 2px solid #fff;
        }
    </style>
</head>
<body>

    <!-- Left-hand menu panel -->
    <div class="menu-panel">
        <!-- Tab navigation buttons -->
        <div class="menu-nav-button-container">
            <button id="bravaisBtn" class="menu-nav-button active">Bravais Lattice</button>
            <button id="basisBtn" class="menu-nav-button">Basis</button>
            <button id="unitCellBtn" class="menu-nav-button">Unit Cell</button>
        </div>

        <!-- Bravais Lattice content section -->
        <div id="bravaisSection" class="menu-section active">
            <h2>Bravais Lattice</h2>
            <button id="cubicPBtn" class="menu-button">Cubic P</button>
            <button id="cubicIBtn" class="menu-button">Cubic I</button>
            <button id="cubicFBtn" class="menu-button">Cubic F</button>
        </div>

        <!-- Basis content section -->
        <div id="basisSection" class="menu-section">
            <h2>Add Atom to Basis</h2>
            <div class="input-group">
                <label>Fractional Coordinates</label>
                <div class="input-group-inline">
                    <input type="number" id="basisX" value="0" step="0.1">
                    <input type="number" id="basisY" value="0" step="0.1">
                    <input type="number" id="basisZ" value="0" step="0.1">
                </div>
            </div>
            <div class="input-group">
                <label for="basisColor">Atom Color</label>
                <input type="color" id="basisColor" value="#ff8800">
            </div>
            <button id="addAtomBtn" class="menu-button">Add Atom</button>
            <button id="clearBasisBtn" class="menu-button" style="background-color: #dc3545;">Clear Basis</button>
            
            <h3>Current Basis</h3>
            <div id="atomList" class="atom-list">
                <!-- Atom list items will be dynamically added here -->
            </div>
        </div>

        <!-- Unit Cell content section -->
        <div id="unitCellSection" class="menu-section">
            <h2>Unit Cell</h2>
            <div class="input-group">
                <label for="numX">Number of Cells (X-dir)</label>
                <input type="number" id="numX" value="1" min="1">
            </div>
            <div class="input-group">
                <label for="numY">Number of Cells (Y-dir)</label>
                <input type="number" id="numY" value="1" min="1">
            </div>
            <div class="input-group">
                <label for="numZ">Number of Cells (Z-dir)</label>
                <input type="number" id="numZ" value="1" min="1">
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showLinesCheckbox" checked>
                <label for="showLinesCheckbox">Show Unit Cell Lines</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showFacesCheckbox">
                <label for="showFacesCheckbox">Show Unit Cell Faces</label>
            </div>
        </div>
    </div>

    <!-- Right-hand renderer container -->
    <div class="renderer-container" id="rendererContainer">
        <!-- The canvas will be appended here by the JavaScript -->
    </div>

    <!-- The script tag for Three.js must be loaded first -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Use window.onload to ensure the entire page and its resources are loaded before running the script
        window.onload = function() {

            // Get all relevant DOM elements
            const bravaisBtn = document.getElementById('bravaisBtn');
            const basisBtn = document.getElementById('basisBtn');
            const unitCellBtn = document.getElementById('unitCellBtn');
            const bravaisSection = document.getElementById('bravaisSection');
            const basisSection = document.getElementById('basisSection');
            const unitCellSection = document.getElementById('unitCellSection');
            const rendererContainer = document.getElementById('rendererContainer');
            const cubicPBtn = document.getElementById('cubicPBtn');
            const cubicIBtn = document.getElementById('cubicIBtn');
            const cubicFBtn = document.getElementById('cubicFBtn');
            const numXInput = document.getElementById('numX');
            const numYInput = document.getElementById('numY');
            const numZInput = document.getElementById('numZ');
            const showLinesCheckbox = document.getElementById('showLinesCheckbox');
            const showFacesCheckbox = document.getElementById('showFacesCheckbox');
            
            // New UI elements for the basis tab
            const basisXInput = document.getElementById('basisX');
            const basisYInput = document.getElementById('basisY');
            const basisZInput = document.getElementById('basisZ');
            const basisColorInput = document.getElementById('basisColor');
            const addAtomBtn = document.getElementById('addAtomBtn');
            const clearBasisBtn = document.getElementById('clearBasisBtn');
            const atomListDiv = document.getElementById('atomList');


            // --- Scene Setup ---
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a); // Dark background

            // --- Camera Setup ---
            const camera = new THREE.PerspectiveCamera(75, rendererContainer.clientWidth / rendererContainer.clientHeight, 0.1, 1000);
            camera.position.z = 5; // Set the initial camera position, moved back to see more of the lattice

            // --- Renderer Setup ---
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(rendererContainer.clientWidth, rendererContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            rendererContainer.appendChild(renderer.domElement);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            // --- State variables for rendering mode and basis ---
            let currentObjects = [];
            let currentLatticeGenerator = generateUnitCellPPoints; // Default to Cubic P
            let currentBasis = [{ x: 0, y: 0, z: 0, color: '#ffffff' }]; // Default basis is a single atom at the origin
            const spacing = 4; // Global spacing variable for the lattice points

            // --- Scene Cleanup Function ---
            function clearScene() {
                // Remove all existing objects from the scene
                currentObjects.forEach(obj => {
                    scene.remove(obj);
                    // Dispose of the geometry and material to free up memory
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                });
                // Clear the tracking array
                currentObjects = [];
            }

            // --- Unit Cell Point Generation Functions ---
            // Generates the points for a single simple cubic unit cell (8 points)
            function generateUnitCellPPoints() {
                const points = [];
                // Add the 8 corner points of a unit cube
                for (let x = 0; x <= 1; x++) {
                    for (let y = 0; y <= 1; y++) {
                        for (let z = 0; z <= 1; z++) {
                            points.push(new THREE.Vector3(x, y, z));
                        }
                    }
                }
                return points;
            }

            // Generates the points for a single Body-Centered Cubic (BCC) unit cell (9 points)
            function generateUnitCellIPoints() {
                const points = [];
                // Add the 8 corner points
                for (let x = 0; x <= 1; x++) {
                    for (let y = 0; y <= 1; y++) {
                        for (let z = 0; z <= 1; z++) {
                            points.push(new THREE.Vector3(x, y, z));
                        }
                    }
                }
                // Add the single body-centered point
                points.push(new THREE.Vector3(0.5, 0.5, 0.5));
                return points;
            }

            // Generates the points for a single Face-Centered Cubic (FCC) unit cell (14 points)
            function generateUnitCellFPoints() {
                const points = [];
                // Add the 8 corner points
                for (let x = 0; x <= 1; x++) {
                    for (let y = 0; y <= 1; y++) {
                        for (let z = 0; z <= 1; z++) {
                            points.push(new THREE.Vector3(x, y, z));
                        }
                    }
                }
                // Add the 6 face-centered points
                points.push(new THREE.Vector3(0.5, 0.5, 0)); // Bottom face
                points.push(new THREE.Vector3(0.5, 0.5, 1)); // Top face
                points.push(new THREE.Vector3(0.5, 0, 0.5)); // Back face
                points.push(new THREE.Vector3(0.5, 1, 0.5)); // Front face
                points.push(new THREE.Vector3(0, 0.5, 0.5)); // Left face
                points.push(new THREE.Vector3(1, 0.5, 0.5)); // Right face
                return points;
            }

            // --- Expanded Lattice Generation Function ---
            // This function takes the points of a single unit cell and expands them
            function generateFullLattice(unitCellPoints, numX, numY, numZ) {
                const fullLatticePoints = new Set();
                for (let i = 0; i < numX; i++) {
                    for (let j = 0; j < numY; j++) {
                        for (let k = 0; k < numZ; k++) {
                            unitCellPoints.forEach(point => {
                                // Add a new lattice point by translating the unit cell point
                                // Use a string representation for the Set to handle unique points across cells
                                const translatedPoint = new THREE.Vector3(
                                    point.x + i,
                                    point.y + j,
                                    point.z + k
                                );
                                fullLatticePoints.add(`${translatedPoint.x},${translatedPoint.y},${translatedPoint.z}`);
                            });
                        }
                    }
                }

                // Convert back to THREE.Vector3 objects
                const uniqueLatticePoints = Array.from(fullLatticePoints).map(str => {
                    const parts = str.split(',').map(Number);
                    return new THREE.Vector3(parts[0], parts[1], parts[2]);
                });
                return uniqueLatticePoints;
            }

            // --- Function to add lines to the scene ---
            function addUnitCellLines(numX, numY, numZ) {
                const linePoints = [];
                const addedLines = new Set();

                // Define the 8 corner points of a single unit cube
                const cornerPoints = [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(1, 0, 0),
                    new THREE.Vector3(0, 1, 0),
                    new THREE.Vector3(1, 1, 0),
                    new THREE.Vector3(0, 0, 1),
                    new THREE.Vector3(1, 0, 1),
                    new THREE.Vector3(0, 1, 1),
                    new THREE.Vector3(1, 1, 1)
                ];

                // Define the 12 edges of a single unit cube
                const edgeIndices = [
                    0, 1, 1, 3, 3, 2, 2, 0, // Bottom face
                    4, 5, 5, 7, 7, 6, 6, 4, // Top face
                    0, 4, 1, 5, 2, 6, 3, 7  // Vertical edges
                ];

                // Calculate offset to center the entire lattice
                const offsetX = (numX - 1) / 2;
                const offsetY = (numY - 1) / 2;
                const offsetZ = (numZ - 1) / 2;

                for (let i = 0; i < numX; i++) {
                    for (let j = 0; j < numY; j++) {
                        for (let k = 0; k < numZ; k++) {
                            for (let l = 0; l < edgeIndices.length; l += 2) {
                                const start = cornerPoints[edgeIndices[l]];
                                const end = cornerPoints[edgeIndices[l+1]];

                                const translatedStart = new THREE.Vector3(
                                    (start.x + i - offsetX) * spacing,
                                    (start.y + j - offsetY) * spacing,
                                    (start.z + k - offsetZ) * spacing
                                );
                                const translatedEnd = new THREE.Vector3(
                                    (end.x + i - offsetX) * spacing,
                                    (end.y + j - offsetY) * spacing,
                                    (end.z + k - offsetZ) * spacing
                                );

                                // Create a unique key for the line to prevent duplicates
                                const key1 = `${translatedStart.x},${translatedStart.y},${translatedStart.z}-${translatedEnd.x},${translatedEnd.y},${translatedEnd.z}`;
                                const key2 = `${translatedEnd.x},${translatedEnd.y},${translatedEnd.z}-${translatedStart.x},${translatedStart.y},${translatedStart.z}`;

                                if (!addedLines.has(key1) && !addedLines.has(key2)) {
                                    linePoints.push(translatedStart, translatedEnd);
                                    addedLines.add(key1);
                                }
                            }
                        }
                    }
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(linePoints);
                const material = new THREE.LineBasicMaterial({ color: 0xcccccc }); // Subtle gray lines
                const lines = new THREE.LineSegments(geometry, material);
                scene.add(lines);
                currentObjects.push(lines);
            }
            
            // --- Function to add transparent faces to the scene ---
            function addUnitCellFaces(numX, numY, numZ) {
                const faceGeometry = new THREE.BoxGeometry(spacing, spacing, spacing);
                const faceMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff, // White color
                    transparent: true,
                    opacity: 0.1,
                });
                
                // Calculate offset to center the entire lattice
                const offsetX = (numX - 1) / 2;
                const offsetY = (numY - 1) / 2;
                const offsetZ = (numZ - 1) / 2;

                for (let i = 0; i < numX; i++) {
                    for (let j = 0; j < numY; j++) {
                        for (let k = 0; k < numZ; k++) {
                            const faceMesh = new THREE.Mesh(faceGeometry, faceMaterial);
                            // Correct the position to be the center of the unit cell, not the corner
                            faceMesh.position.set(
                                (i - offsetX + 0.5) * spacing,
                                (j - offsetY + 0.5) * spacing,
                                (k - offsetZ + 0.5) * spacing
                            );
                            scene.add(faceMesh);
                            currentObjects.push(faceMesh);
                        }
                    }
                }
            }


            // --- Main Rendering Function ---
            // This function renders the atoms based on the lattice points and the basis
            function renderCrystalStructure(latticePoints, basis, numX, numY, numZ) {
                clearScene(); // Clear any objects from the previous render
                
                // Calculate offset to center the entire lattice
                const offsetX = (numX - 1) / 2;
                const offsetY = (numY - 1) / 2;
                const offsetZ = (numZ - 1) / 2;

                // For each lattice point...
                latticePoints.forEach(latticePoint => {
                    // ...and for each atom in the basis...
                    basis.forEach(atom => {
                        const geometry = new THREE.SphereGeometry(0.25, 32, 32);
                        const material = new THREE.MeshPhongMaterial({ color: atom.color, emissive: new THREE.Color(atom.color).multiplyScalar(0.2) });
                        const sphere = new THREE.Mesh(geometry, material);

                        // Calculate the final position by adding the basis offset and centering the whole structure
                        sphere.position.set(
                            (latticePoint.x - offsetX) * spacing + atom.x * spacing,
                            (latticePoint.y - offsetY) * spacing + atom.y * spacing,
                            (latticePoint.z - offsetZ) * spacing + atom.z * spacing
                        );
                        
                        scene.add(sphere);
                        currentObjects.push(sphere); // Add the sphere to our tracking array
                    });
                });
            }

            // --- Render a single unit cell and its basis ---
            function renderBasisOnly() {
                clearScene(); // Clear existing objects
                
                // Render the unit cell
                addUnitCellLines(1, 1, 1);
                addUnitCellFaces(1, 1, 1);
                
                // Render the atoms in the basis
                renderCrystalStructure([new THREE.Vector3(0, 0, 0)], currentBasis, 1, 1, 1);
            }

            // --- Main Render Orchestration Function ---
            // This function gets the necessary data and triggers the render
            function renderCurrentLattice() {
                const numX = Math.max(1, parseInt(numXInput.value, 10) || 1);
                const numY = Math.max(1, parseInt(numYInput.value, 10) || 1);
                const numZ = Math.max(1, parseInt(numZInput.value, 10) || 1);
                
                // The current unit cell points are generated by the active generator function
                const unitCellPoints = currentLatticeGenerator();
                const latticePoints = generateFullLattice(unitCellPoints, numX, numY, numZ);

                renderCrystalStructure(latticePoints, currentBasis, numX, numY, numZ);
                
                // Add lines if the checkbox is checked
                if (showLinesCheckbox.checked) {
                    addUnitCellLines(numX, numY, numZ);
                }
                
                // Add faces if the checkbox is checked
                if (showFacesCheckbox.checked) {
                    addUnitCellFaces(numX, numY, numZ);
                }
            }

            // --- Function to update the atom list UI ---
            function updateBasisDisplay() {
                atomListDiv.innerHTML = '';
                if (currentBasis.length === 0) {
                    atomListDiv.innerHTML = '<p>No atoms added yet.</p>';
                    return;
                }
                currentBasis.forEach(atom => {
                    const item = document.createElement('div');
                    item.className = 'atom-item';
                    item.innerHTML = `
                        <span class="atom-dot" style="background-color: ${atom.color};"></span>
                        <span>(${atom.x}, ${atom.y}, ${atom.z})</span>
                    `;
                    atomListDiv.appendChild(item);
                });
            }

            // --- UI and Event Listeners for Tabs ---
            function showSection(sectionId) {
                bravaisSection.classList.remove('active');
                basisSection.classList.remove('active');
                unitCellSection.classList.remove('active');
                document.getElementById(sectionId).classList.add('active');
            }

            function setActiveNavButton(buttonId) {
                bravaisBtn.classList.remove('active');
                basisBtn.classList.remove('active');
                unitCellBtn.classList.remove('active');
                document.getElementById(buttonId).classList.add('active');
            }

            bravaisBtn.addEventListener('click', () => {
                showSection('bravaisSection');
                setActiveNavButton('bravaisBtn');
                renderCurrentLattice();
            });

            basisBtn.addEventListener('click', () => {
                showSection('basisSection');
                setActiveNavButton('basisBtn');
                renderBasisOnly();
            });
            
            unitCellBtn.addEventListener('click', () => {
                showSection('unitCellSection');
                setActiveNavButton('unitCellBtn');
                renderCurrentLattice();
            });
            
            // Event listener for the Cubic P button
            cubicPBtn.addEventListener('click', () => {
                currentLatticeGenerator = generateUnitCellPPoints;
                renderCurrentLattice();
            });
            
            // Event listener for the Cubic I button
            cubicIBtn.addEventListener('click', () => {
                currentLatticeGenerator = generateUnitCellIPoints;
                renderCurrentLattice();
            });

            // Event listener for the new Cubic F button
            cubicFBtn.addEventListener('click', () => {
                currentLatticeGenerator = generateUnitCellFPoints;
                renderCurrentLattice();
            });

            // Event listener for adding an atom to the basis
            addAtomBtn.addEventListener('click', () => {
                const newAtom = {
                    x: parseFloat(basisXInput.value),
                    y: parseFloat(basisYInput.value),
                    z: parseFloat(basisZInput.value),
                    color: basisColorInput.value
                };
                currentBasis.push(newAtom);
                updateBasisDisplay();
                // Check which tab is active before rendering
                if (basisSection.classList.contains('active')) {
                    renderBasisOnly();
                } else {
                    renderCurrentLattice();
                }
            });
            
            // Event listener to clear the basis
            clearBasisBtn.addEventListener('click', () => {
                currentBasis = []; // Reset the basis to an empty array
                updateBasisDisplay();
                if (basisSection.classList.contains('active')) {
                    renderBasisOnly();
                } else {
                    renderCurrentLattice();
                }
            });

            // Event listeners for the unit cell count inputs
            numXInput.addEventListener('input', renderCurrentLattice);
            numYInput.addEventListener('input', renderCurrentLattice);
            numZInput.addEventListener('input', renderCurrentLattice);
            showLinesCheckbox.addEventListener('change', renderCurrentLattice);
            showFacesCheckbox.addEventListener('change', renderCurrentLattice);


            // --- Initial render on page load ---
            renderCurrentLattice();
            updateBasisDisplay();


            // --- Interaction (Mouse & Touch) ---
            let isDragging = false;
            let isPanning = false;
            let previousMousePosition = { x: 0, y: 0 };
            const rotationSpeed = 0.005;
            const panSpeed = 0.01;
            const zoomSpeed = 0.05;

            renderer.domElement.addEventListener('mousedown', (event) => {
                isDragging = true;
                isPanning = event.shiftKey;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
                isPanning = false;
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (isDragging) {
                    const deltaMove = {
                        x: event.clientX - previousMousePosition.x,
                        y: event.clientY - previousMousePosition.y,
                    };

                    if (isPanning) {
                        const vector = new THREE.Vector3(-deltaMove.x * panSpeed, deltaMove.y * panSpeed, 0);
                        camera.position.add(vector);
                    } else {
                        const rotationY = deltaMove.x * rotationSpeed;
                        const rotationX = deltaMove.y * rotationSpeed;
                        scene.rotation.y += rotationY;
                        scene.rotation.x += rotationX;
                    }

                    previousMousePosition.x = event.clientX;
                    previousMousePosition.y = event.clientY;
                }
            });

            renderer.domElement.addEventListener('wheel', (event) => {
                camera.position.z += event.deltaY * zoomSpeed;
                camera.position.z = Math.max(1, Math.min(100, camera.position.z));
            });
            
            renderer.domElement.addEventListener('touchstart', (event) => {
                if (event.touches.length === 1) {
                    isDragging = true;
                    isPanning = false;
                    previousMousePosition.x = event.touches[0].clientX;
                    previousMousePosition.y = event.touches[0].clientY;
                } else if (event.touches.length === 2) {
                    isPanning = true;
                }
            });

            renderer.domElement.addEventListener('touchend', () => {
                isDragging = false;
                isPanning = false;
            });

            renderer.domElement.addEventListener('touchmove', (event) => {
                if (isDragging && event.touches.length === 1) {
                    const deltaMove = {
                        x: event.touches[0].clientX - previousMousePosition.x,
                        y: event.touches[0].clientY - previousMousePosition.y,
                    };
                    const rotationY = deltaMove.x * rotationSpeed;
                    const rotationX = deltaMove.y * rotationSpeed;
                    scene.rotation.y += rotationY;
                    scene.rotation.x += rotationX;
                    previousMousePosition.x = event.touches[0].clientX;
                    previousMousePosition.y = event.touches[0].clientY;
                }
            });

            // --- Responsiveness ---
            window.addEventListener('resize', () => {
                const newWidth = rendererContainer.clientWidth;
                const newHeight = rendererContainer.clientHeight;
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
            });

            // --- Animation Loop ---
            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }

            // Start the animation loop
            animate();
        };
    </script>
</body>
</html>
